#' Alert user if NAs are present
#'
#' @param data Data frame from which observations are generated by sample_locally.
#' @param explained_instance A row in an original data frame (as a data.frame).
#'
#' @return Warning message
#'

check_for_na <- function(data, explained_instance) {
  if(any(is.na(explained_instance))) warning("Missing values present in explained instance.")
  if(any(is.na(data))) warning("Missing values present in dataset. NAs will be omitted while sampling.")
}


#' Check if data, explained instance and size make sense.
#'
#' @param data Data frame from which observations will be sampled.
#' @param explained_instance Instance around which points will be sampled.
#' @param size Number of observation in simulated dataset
#'
#' @return Produces an error if any of conditions aren't met.
#'

check_conditions <- function(data, explained_instance, size) {
  if(nrow(data) == 0) stop("Empty data frame")
  if(ncol(data) == 0) stop("Data frame has no columns")
  if(size <= 0 | !is.finite(size)) stop("Size has to be a positive integer")
  if(any(colnames(data) != colnames(explained_instance)))
    stop("Explained instance must have the same variables as data")
}


#' Set date values to one value
#'
#' @param data Data frame to change.
#' @param explained_instance Instance that will be explained.
#' @param col_names Names of columns to be fixed
#'

set_constant_variables <- function(data, explained_instance, col_names) {
  cols <- (1:ncol(data))[which(colnames(data) %in% col_names)]
  if(length(cols) == 0) {
    return(data)
  } else {
    for(k in cols) {
      data.table::set(data, j = as.integer(k),
                      value = explained_instance[1, as.integer(k)])
    }
    data
  }
}


#' LIME: sampling for local exploration by changing one value per observation.
#'
#' @param data Data frame from which observations will be generated.
#' @param explained_instance A row in an original data frame (as a data.frame).
#' @param size Number of observations to be generated.
#' @param fixed_variables Names of column which will not be changed while sampling.
#' @param seed Seed to set before sampling. If NULL, results will not be reproducible.
#'
#' @return data.frame
#'
#'

generate_neighbourhood <- function(data, explained_instance, size, fixed_variables, seed = NULL) {
  data <- data.table::as.data.table(data)
  neighbourhood <- data.table::rbindlist(lapply(1:size, function(x) explained_instance))
  chosen_indices <- sample(1:ncol(data), nrow(neighbourhood), replace = T)
  if(!is.null(seed)) {
    set.seed(seed)
  }
  for(k in 1:nrow(neighbourhood)) {
    data.table::set(neighbourhood, i = as.integer(k), j = as.integer(chosen_indices[k]),
                    data[sample(1:nrow(data), 1), chosen_indices[k], with = FALSE])
  }
  list(data = as.data.frame(set_constant_variables(neighbourhood, explained_instance,
                                                   fixed_variables)),
       indices = chosen_indices)
  
}
#' Calculate weights for explanation model
#'
#' @param simulated_dataset Dataset simulated by sample_locally function.
#' @param explained_instance Instance to be explained.
#' @param kernel Chosen kernel function.
#'
#' @return Numeric vector of weights for each row in simulated dataset.
#'

calculate_weights <- function(simulated_dataset, explained_instance, kernel) {
  for_weights_x <- dplyr::bind_rows(simulated_dataset, explained_instance)
  for_weights_x <- dplyr::mutate_if(for_weights_x, is.character, as.factor)
  proxy_response <- rep(1, nrow(for_weights_x))
  for_weights <- dplyr::bind_cols(y = proxy_response, for_weights_x)
  proxy_model <- stats::lm(y ~., data = for_weights)
  model_matrix <- stats::model.matrix(proxy_model)
  explained_instance_coords <- model_matrix[nrow(model_matrix), ]
  other_observations_coords <- model_matrix[1:(nrow(model_matrix) - 1), ]
  sapply(as.data.frame(t(other_observations_coords)),
         function(x) kernel(explained_instance_coords, x))
}

#' Select variables for explanation model.
#'
#' @param source_data Simulated dataset.
#' @param target Name of the response variable.
#' @param response_family Name of distribution family to be used in lasso/glm fit.
#'
#' @importFrom stats as.formula model.matrix
#'
#' @return Character vector of names of selected variables
#'

select_variables <- function(source_data, target, response_family) {
  form <- as.formula(paste(target, "~."))
  explained_var_col <- which(colnames(source_data) == target)
  lasso_fit <- glmnet::cv.glmnet(model.matrix(form, data = source_data),
                                 as.matrix(source_data[, explained_var_col]),
                                 family = response_family,
                                 nfolds = 5, alpha = 1)
  coefs_lasso <- glmnet::coef.cv.glmnet(lasso_fit)
  nonzero_coefs <- row.names(coefs_lasso)[which(as.numeric(coefs_lasso) != 0)]
  nonzero_coefs <- nonzero_coefs[nonzero_coefs != "(Intercept)"]
  factors <- colnames(source_data)[sapply(source_data,
                                          function(x)
                                            is.character(x) | is.factor(x))]
  selected_vars <- colnames(source_data)[colnames(source_data) %in% nonzero_coefs]
  
  if(length(factors) != 0) {
    selected_vars <- selected_vars[!is.na(selected_vars)]
    factors_lasso <- setdiff(nonzero_coefs, selected_vars)
    selected_factors_lgl <- sapply(factors, function(x) any(grepl(x, factors_lasso)))
    selected_factors <- names(selected_factors_lgl)[selected_factors_lgl]
    selected_vars <- c(selected_vars,
                       selected_factors)
  }
  selected_vars
}

#' Fit white box model to the simulated data.
#'
#' @param live_object List return by add_predictions function.
#' @param white_box String, learner name recognized by mlr package.
#' @param kernel function which will be used to calculate distance between simulated
#'        observations and explained instance.
#' @param standardize If TRUE, numerical variables will be scaled to have mean 0, variance 1
#'        before fitting explanation model.
#' @param selection If TRUE, variable selection based on glmnet implementation of LASSO
#'        will be performed.
#' @param response_family family argument to glmnet (and then glm) function.
#'        Default value is "gaussian"
#' @param predict_type Argument passed to mlr::makeLearner() argument "predict.type".
#'        Defaults to "response".
#' @param hyperpars Optional list of values of hyperparameteres of a model.
#'
#' @return List consting of
#' \item{data}{Dataset used to fit explanation model (may have less column than the original)}
#' \item{model}{Fitted explanation model}
#' \item{explained_instance}{Instance that is being explained}
#'
#' @export
#'
#' @import mlr
#'
#' @examples
#' \dontrun{
#' fitted_explanation <- fit_explanation2(local_exploration1, "regr.lm", selection = TRUE)
#' }
#'

fit_explanation <- function(live_object, kernel = gaussian_kernel, 
                            selection = FALSE, response_family = "gaussian") {
  
  source_data <- dplyr::select_if(live_object$data,
                                  function(x) dplyr::n_distinct(x) > 1)
  # source_data <- dplyr::mutate_if(source_data, is.factor, droplevels)
  source_data <- dplyr::bind_cols(live_object$data, y = live_object$target)

  # if(selection) {
  #   selected_vars <- select_variables(source_data, live_object$target,
  #                                     response_family)
  # } else {
  #   selected_vars <- colnames(source_data)
  # }
  
  # if(grepl("glm", white_box) & !(response_family == "poisson" | response_family == "binomial")) {
  #   hyperpars <- c(hyperpars, family = response_family)
  # }
  # lrn <- mlr::makeLearner(white_box, predict.type = predict_type, par.vals = hyperpars)
  
  explainer <- list(data = source_data,
                    model = lm(y ~., data = source_data),
                    explained_instance = live_object$explained_instance,
                    # weights = live_weights,
                    selected_variables = selection)
  
  class(explainer) <- c("live_explainer", "list")
  explainer
}


#' Waterfall plot or forestplot for lm/glm explanations.
#'
#' @param plot_type Chr, "forest" or "waterfall" depending
#'                  on which type of plot is to be created.
#' @param fitted_model glm or lm object.
#' @param explained_instance Observation around which model was fitted.
#' @param classif logical, if TRUE, probabilities will be plotted 
#'
#' @importFrom graphics plot
#'
#' @return plot (ggplot2 or lattice)
#'

plot_regression <- function(plot_type, fitted_model, explained_instance, classif) {
  if(plot_type == "forest") {
    forestmodel::forest_model(fitted_model)
  } else {
    plot(breakDown::broken(fitted_model, explained_instance, baseline = "Intercept"))
  }
}


#' Plotting white box models.
#'
#' @param x List returned by fit_explanation function.
#' @param type Chr, "forest" or "waterfall" depending
#'        on which type of plot is to be created.
#'        if lm/glm model is used as interpretable approximation.
#' @param ... Additional parameters.
#'
#' @return plot (ggplot2 or base)
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Forest plot for regression
#' plot(fitted_explanation1, type = "forest")
#' # Waterfall plot
#' plot(fitted_explanation1, type = "waterfall")
#' # Plot decision tree
#' plot(fitted_explanation2)
#' }
#'

plot.live_explainer <- function(x, type = "waterfall", ...) {
  trained_model <- x$model
  plot_regression(type, trained_model, x$explained_instance)
}

