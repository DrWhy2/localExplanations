#' Alert user if NAs are present
#'
#' @param data Data frame from which observations are generated by sample_locally.
#' @param explained_instance A row in an original data frame (as a data.frame).
#'
#' @return Warning message
#'

check_for_na <- function(data, explained_instance) {
  if(any(is.na(explained_instance))) warning("Missing values present in explained instance.")
  if(any(is.na(data))) warning("Missing values present in dataset. NAs will be omitted while sampling.")
}


#' Set date values to one value
#'
#' @param data Data frame to change.
#' @param explained_instance Instance that will be explained.
#' @param col_names Names of columns to be fixed
#'

set_constant_variables <- function(data, explained_instance, col_names) {
  cols <- (1:ncol(data))[which(colnames(data) %in% col_names)]
  if(length(cols) == 0) {
    return(data)
  } else {
    for(k in cols) {
      data.table::set(data, j = as.integer(k),
                      value = explained_instance[1, as.integer(k)])
    }
    data
  }
}


#' LIME: sampling for local exploration by changing one value per observation.
#'
#' @param data Data frame from which observations will be generated.
#' @param explained_instance A row in an original data frame (as a data.frame).
#' @param size Number of observations to be generated.
#' @param fixed_variables Names of column which will not be changed while sampling.
#' @param seed Seed to set before sampling. If NULL, results will not be reproducible.
#'
#' @return data.frame
#'
#'

generate_neighbourhood <- function(data, explained_instance, size, fixed_variables, seed = NULL) {
  data <- data.table::as.data.table(data)
  neighbourhood <- data.table::rbindlist(lapply(1:size, function(x) explained_instance))
  chosen_indices <- sample(1:ncol(data), nrow(neighbourhood), replace = T)
  if(!is.null(seed)) {
    set.seed(seed)
  }
  for(k in 1:nrow(neighbourhood)) {
    data.table::set(neighbourhood, i = as.integer(k), j = as.integer(chosen_indices[k]),
                    data[sample(1:nrow(data), 1), chosen_indices[k], with = FALSE])
  }
  as.data.frame(set_constant_variables(neighbourhood, explained_instance, fixed_variables))
}


#' Fit white box model to the simulated data.
#'
#' @param live_object List return by add_predictions function.
#' @param kernel function which will be used to calculate distance between simulated
#'        observations and explained instance.
#' @param response_family family argument to glmnet (and then glm) function.
#'        Default value is "gaussian"
#'
#' @return List consting of
#' \item{data}{Dataset used to fit explanation model (may have less column than the original)}
#' \item{model}{Fitted explanation model}
#' \item{explained_instance}{Instance that is being explained}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' fitted_explanation <- fit_explanation2(local_exploration1, "regr.lm", selection = TRUE)
#' }
#'

fit_explanation <- function(live_object, kernel = gaussian_kernel,
                            response_family = "gaussian") {

  source_data <- dplyr::select_if(live_object$data,
                                  function(x) dplyr::n_distinct(x) > 1)
  # source_data <- dplyr::mutate_if(source_data, is.factor, droplevels)
  source_data <- dplyr::bind_cols(source_data, y = live_object$target)
  model_matrix <- model.matrix(y ~ ., data = source_data)

  model <- glmnet::cv.glmnet(model_matrix[, -1], live_object$target,
                             family = response_family, alpha = 1)

  var_names <- data.frame("variable" = rownames(coef(model)))
  coefs <- as.data.frame(as.matrix(coef(model)))

  list(simulated_data = source_data,
       model_coefs = dplyr::bind_cols(var_names, coefs) ,
       explained_instance = live_object$explained_instance)
}

#' @import ggplot2

plot.local_surrogate_explainer <- function(x, ...) {
  if(length(x) == 1) {
    binded_levels <- x[[1]]$model_coefs
  } else {
    just_coefs <- lapply(x, function(y) y$model_coefs)
    binded_levels <- suppressWarnings(dplyr::bind_rows(just_coefs))
  }
  colnames(binded_levels)[2] <- "estimated"
  var_names <- unique(binded_levels$variable)
  ggplot(binded_levels, aes(x = reorder(variable, abs(estimated)),
                            y = estimated)) +
    theme_bw() +
    geom_hline(data = data.frame(variable = rep(var_names, times = 3),
                                 estimated = 0,
                                 response = rep(unique(binded_levels$response),
                                                each = length(var_names))),
               aes(yintercept = estimated),
               size = 1.1)  +
    geom_pointrange(aes(ymin = 0, ymax = estimated)) +
    facet_wrap(~response) +
    coord_flip() +
    ylab("Estimated effect") +
    xlab("Variable / level")
}


merge_factor_levels <- function(response, factor, ...) {
  factor_levels <- sort(levels(factor))
  mf_result <- factorMerger::mergeFactors(response, factor)
  partition_df <- getOptimalPartitionDf(mf_result)
  original_levels <- partition_df[, 2]
  names(original_levels) <- partition_df[, 1]

}
