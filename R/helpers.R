#' Alert user if NAs are present
#'
#' @param data Data frame from which observations are generated by sample_locally.
#' @param explained_instance A row in an original data frame (as a data.frame).
#'
#' @return Warning message
#'

check_for_na <- function(data, explained_instance) {
  if(any(is.na(explained_instance))) warning("Missing values present in explained instance.")
  if(any(is.na(data))) warning("Missing values present in dataset. NAs will be omitted while sampling.")
}


#' Set date values to one value
#'
#' @param data Data frame to change.
#' @param explained_instance Instance that will be explained.
#' @param col_names Names of columns to be fixed
#'

set_constant_variables <- function(data, explained_instance, col_names) {
  cols <- (1:ncol(data))[which(colnames(data) %in% col_names)]
  if(length(cols) == 0) {
    return(data)
  } else {
    for(k in cols) {
      data.table::set(data, j = as.integer(k),
                      value = explained_instance[1, as.integer(k)])
    }
    data
  }
}


#' LIME: sampling for local exploration by changing one value per observation.
#'
#' @param data Data frame from which observations will be generated.
#' @param explained_instance A row in an original data frame (as a data.frame).
#' @param size Number of observations to be generated.
#' @param fixed_variables Names of column which will not be changed while sampling.
#' @param seed Seed to set before sampling. If NULL, results will not be reproducible.
#'
#' @return data.frame
#'
#'

generate_neighbourhood <- function(data, explained_instance, size, fixed_variables, seed = NULL) {
  data <- data.table::as.data.table(data)
  neighbourhood <- data.table::rbindlist(lapply(1:size, function(x) explained_instance))
  chosen_indices <- sample(1:ncol(data), nrow(neighbourhood), replace = T)
  if(!is.null(seed)) {
    set.seed(seed)
  }
  for(k in 1:nrow(neighbourhood)) {
    data.table::set(neighbourhood, i = as.integer(k), j = as.integer(chosen_indices[k]),
                    data[sample(1:nrow(data), 1), chosen_indices[k], with = FALSE])
  }
  as.data.frame(set_constant_variables(neighbourhood, explained_instance, fixed_variables))
}


#' Fit white box model to the simulated data.
#'
#' @param live_object List return by add_predictions function.
#' @param kernel function which will be used to calculate distance between simulated
#'        observations and explained instance.
#'
#' @return List consting of
#' \item{data}{Dataset used to fit explanation model (may have less column than the original)}
#' \item{model}{Fitted explanation model}
#' \item{explained_instance}{Instance that is being explained}
#'
#' @importFrom stats model.matrix coef
#'
#' @export
#'
#' @examples
#' \dontrun{
#' fitted_explanation <- fit_explanation2(local_exploration1, "regr.lm", selection = TRUE)
#' }
#'

fit_explanation <- function(live_object, kernel = gaussian_kernel, penalty = NULL) {

  source_data <- dplyr::select_if(live_object$data,
                                  function(x) dplyr::n_distinct(x) > 1)
  # source_data <- dplyr::mutate_if(source_data, is.factor, droplevels)
  source_data <- dplyr::bind_cols(source_data, y = live_object$target)
  model_matrix <- model.matrix(y ~ ., data = source_data)

  if(is.null(penalty)) {
    model <- glmnet::cv.glmnet(model_matrix[, -1], live_object$target,
                               family = "gaussian", alpha = 1)
  } else {
    model <- glmnet::glmnet(model_matrix[, -1], live_object$target,
                            family = "gaussian", alpha = 1, lambda = penalty)
  }


  var_names <- data.frame("variable" = rownames(coef(model)))
  coefs <- as.data.frame(as.matrix(coef(model)))

  list(simulated_data = source_data,
       model_coefs = dplyr::bind_cols(var_names, coefs) ,
       explained_instance = live_object$explained_instance)
}


get_original_colnames <- function(transformed_names, original_names) {
  unlist(sapply(transformed_names,
                function(name) {
                  extracted <- stringr::str_extract(name, original_names)
                  extracted[!is.na(extracted)]
                }))
}


#' @import ggplot2
#' @importFrom stats reorder
#' @export

plot.local_surrogate_explainer <- function(x, ...) {
  variable <- estimated <- NULL
  if(length(x) == 1) {
    binded_levels <- x[[1]]$model_coefs
  } else {
    just_coefs <- lapply(x, function(y) y$model_coefs)
    binded_levels <- suppressWarnings(dplyr::bind_rows(just_coefs))
  }
  colnames(binded_levels)[2] <- "estimated"
  binded_levels <- binded_levels[binded_levels$variable != "(Intercept)", ]
  binded_levels$variable <- sort(binded_levels$variable)
  binded_levels$colname <- sort(get_original_colnames(binded_levels$variable,
                                                 colnames(x[[1]]$explained_instance)))
  var_names <- unique(binded_levels$variable)
  binded_levels$variable <- as.character(binded_levels$variable)

  for(i in 1:nrow(binded_levels)) {
    binded_levels$variable[i] <- stringr::str_replace_all(
      binded_levels$variable[i],
      binded_levels$colname[i],
      ""
    )
  }

   ggplot(binded_levels, aes(x = reorder(colname, abs(estimated)),
                            y = estimated,
                            color = variable,
                            label = variable)) +
    theme_bw() +
    geom_hline(data = data.frame(variable = rep(unique(binded_levels$colname), times = 3),
                                 estimated = 0,
                                 response = rep(unique(binded_levels$response),
                                                each = length(unique(binded_levels$colname)))),
               aes(yintercept = estimated),
               size = 1.1)  +
    geom_pointrange(aes(ymin = 0, ymax = estimated)) +
    facet_wrap(~response) +
    coord_flip() +
    ylab("Estimated effect") +
    xlab("Variable / level") +
    geom_text()
}


merge_factor_levels <- function(response, factor) {
  mf_result <- factorMerger::mergeFactors(response, factor)
  old_levels <- mf_result$map$original
  names(old_levels) <- mf_result$map$recoded
  partition_df <- factorMerger::getOptimalPartitionDf(mf_result)
  partition_df$original_levels <- old_levels[as.character(partition_df$orig)]
  partition_df$pred <- stringr::str_replace_all(partition_df$pred,
                                                "\\)\\(", "_")
  partition_df$pred <- stringr::str_replace_all(partition_df$pred,
                                                "[()]", "")
  merged_levels <- partition_df$pred
  names(merged_levels) <- partition_df$original_levels
  as.factor(merged_levels[as.character(factor)])
}
