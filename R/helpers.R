#' Alert user if NAs are present
#'
#' @param data Data frame from which observations are generated by sample_locally.
#' @param explained_instance A row in an original data frame (as a data.frame).
#'
#' @return Warning message
#'

check_for_na <- function(data, explained_instance) {
  if(any(is.na(explained_instance))) warning("Missing values present in explained instance.")
  if(any(is.na(data))) warning("Missing values present in dataset. NAs will be omitted while sampling.")
}


#' Check if data, explained instance and size make sense.
#'
#' @param data Data frame from which observations will be sampled.
#' @param explained_instance Instance around which points will be sampled.
#' @param size Number of observation in simulated dataset
#'
#' @return Produces an error if any of conditions aren't met.
#'

check_conditions <- function(data, explained_instance, size) {
  if(nrow(data) == 0) stop("Empty data frame")
  if(ncol(data) == 0) stop("Data frame has no columns")
  if(size <= 0 | !is.finite(size)) stop("Size has to be a positive integer")
  if(any(colnames(data) != colnames(explained_instance)))
    stop("Explained instance must have the same variables as data")
}


#' Set date values to one value
#'
#' @param data Data frame to change.
#' @param explained_instance Instance that will be explained.
#' @param col_names Names of columns to be fixed
#'

set_constant_variables <- function(data, explained_instance, col_names) {
  cols <- (1:ncol(data))[which(colnames(data) %in% col_names)]
  if(length(cols) == 0) {
    return(data)
  } else {
    for(k in cols) {
      data.table::set(data, j = as.integer(k),
                      value = explained_instance[1, as.integer(k)])
    }
    data
  }
}


#' LIME: sampling for local exploration by changing one value per observation.
#'
#' @param data Data frame from which observations will be generated.
#' @param explained_instance A row in an original data frame (as a data.frame).
#' @param size Number of observations to be generated.
#' @param fixed_variables Names of column which will not be changed while sampling.
#' @param seed Seed to set before sampling. If NULL, results will not be reproducible.
#'
#' @return data.frame
#'
#'

generate_neighbourhood <- function(data, explained_instance, size, fixed_variables, seed = NULL) {
  data <- data.table::as.data.table(data)
  neighbourhood <- data.table::rbindlist(lapply(1:size, function(x) explained_instance))
  chosen_indices <- sample(1:ncol(data), nrow(neighbourhood), replace = T)
  if(!is.null(seed)) {
    set.seed(seed)
  }
  for(k in 1:nrow(neighbourhood)) {
    data.table::set(neighbourhood, i = as.integer(k), j = as.integer(chosen_indices[k]),
                    data[sample(1:nrow(data), 1), chosen_indices[k], with = FALSE])
  }
  as.data.frame(set_constant_variables(neighbourhood, explained_instance, fixed_variables))
}


#' Fit white box model to the simulated data.
#'
#' @param live_object List return by add_predictions function.
#' @param kernel function which will be used to calculate distance between simulated
#'        observations and explained instance.
#' @param response_family family argument to glmnet (and then glm) function.
#'        Default value is "gaussian"
#'
#' @return List consting of
#' \item{data}{Dataset used to fit explanation model (may have less column than the original)}
#' \item{model}{Fitted explanation model}
#' \item{explained_instance}{Instance that is being explained}
#'
#' @export
#'
#' @examples
#' \dontrun{
#' fitted_explanation <- fit_explanation2(local_exploration1, "regr.lm", selection = TRUE)
#' }
#'

fit_explanation <- function(live_object, kernel = gaussian_kernel,
                            response_family = "gaussian") {

  source_data <- dplyr::select_if(live_object$data,
                                  function(x) dplyr::n_distinct(x) > 1)
  # source_data <- dplyr::mutate_if(source_data, is.factor, droplevels)
  source_data <- dplyr::bind_cols(source_data, y = live_object$target)
  model_matrix <- model.matrix(y ~ ., data = source_data)

  explainer <- list(data = source_data,
                    model = glmnet::cv.glmnet(model_matrix[, -1], live_object$target,
                                              family = response_family, alpha = 1),
                    explained_instance = live_object$explained_instance)

  class(explainer) <- c("live_explainer", "list")
  explainer
}


#' Waterfall plot or forestplot for lm/glm explanations.
#'
#' @param plot_type Chr, "forest" or "waterfall" depending
#'                  on which type of plot is to be created.
#' @param fitted_model glm or lm object.
#' @param explained_instance Observation around which model was fitted.
#' @param classif logical, if TRUE, probabilities will be plotted
#'
#' @importFrom graphics plot
#'
#' @return plot (ggplot2 or lattice)
#'

plot_regression <- function(plot_type, fitted_model, explained_instance, classif) {
  if(plot_type == "forest") {
    forestmodel::forest_model(fitted_model)
  } else {
    plot(breakDown::broken(fitted_model, explained_instance, baseline = "Intercept"))
  }
}


#' Plotting white box models.
#'
#' @param x List returned by fit_explanation function.
#' @param type Chr, "forest" or "waterfall" depending
#'        on which type of plot is to be created.
#'        if lm/glm model is used as interpretable approximation.
#' @param ... Additional parameters.
#'
#' @return plot (ggplot2 or base)
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # Forest plot for regression
#' plot(fitted_explanation1, type = "forest")
#' # Waterfall plot
#' plot(fitted_explanation1, type = "waterfall")
#' # Plot decision tree
#' plot(fitted_explanation2)
#' }
#'

plot.live_explainer <- function(x, type = "waterfall", ...) {
  trained_model <- x$model
  plot_regression(type, trained_model, x$explained_instance)
}

